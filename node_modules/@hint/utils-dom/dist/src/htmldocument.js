"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const parse5 = require("parse5");
const htmlparser2Adapter = require("parse5-htmlparser2-tree-adapter");
const cssSelect = require("css-select");
const create_element_1 = require("./create-element");
const comment_1 = require("./comment");
const documenttype_1 = require("./documenttype");
const node_1 = require("./node");
const text_1 = require("./text");
const CACHED_CSS_SELECTORS = new Map();
class HTMLDocument extends node_1.Node {
    constructor(document, finalHref, originalDocument) {
        super(document, null);
        this._nodes = new Map();
        this._pageHTML = '';
        this._document = document;
        this._documentElement = this.findDocumentElement();
        this.originalDocument = originalDocument;
        this._pageHTML = parse5.serialize(document, { treeAdapter: htmlparser2Adapter });
        this._base = this.getBaseUrl(finalHref);
        this._nodes.set(document, this);
    }
    findDocumentElement() {
        return this._document.children.find((node) => {
            return node.type === 'tag' && node.name === 'html';
        });
    }
    getBaseUrl(finalHref) {
        const baseElement = this.querySelectorAll('base[href]')[0];
        const baseHref = baseElement ? baseElement.getAttribute('href') : null;
        if (!baseHref) {
            return new url_1.URL(finalHref).href;
        }
        return new url_1.URL(baseHref, finalHref).href;
    }
    get documentElement() {
        return this.getNodeFromData(this._documentElement);
    }
    get base() {
        return this._base;
    }
    get body() {
        return this.querySelectorAll('body')[0];
    }
    get compatMode() {
        return this._document['x-mode'] === 'quirks' ?
            'BackCompat' :
            'CSS1Compat';
    }
    get isFragment() {
        return !this.originalDocument && !this._documentElement.sourceCodeLocation;
    }
    get title() {
        var _a;
        return ((_a = this.querySelectorAll('title')[0]) === null || _a === void 0 ? void 0 : _a.textContent) || '';
    }
    createElement(data) {
        return create_element_1.createElement(data, this);
    }
    getNodeFromData(data) {
        if (this._nodes.has(data)) {
            return this._nodes.get(data);
        }
        let node;
        switch (data.type) {
            case 'comment':
                node = new comment_1.Comment(data, this);
                break;
            case 'directive':
                node = new documenttype_1.DocumentType(data, this);
                break;
            case 'script':
            case 'style':
            case 'tag':
                node = create_element_1.createElement(data.name, this, data);
                break;
            case 'text':
                node = new text_1.Text(data, this);
                break;
            default:
                throw new Error(`Unsupported node type: ${data.type}`);
        }
        this._nodes.set(data, node);
        return node;
    }
    elementsFromPoint(x, y) {
        return [];
    }
    pageHTML() {
        return this._pageHTML;
    }
    querySelector(selector) {
        return this.querySelectorAll(selector)[0];
    }
    querySelectorAll(selector) {
        if (!CACHED_CSS_SELECTORS.has(selector)) {
            CACHED_CSS_SELECTORS.set(selector, cssSelect.compile(selector));
        }
        const matches = cssSelect(CACHED_CSS_SELECTORS.get(selector), this._document.children);
        const result = matches.map((element) => {
            return this.getNodeFromData(element);
        });
        return result;
    }
    resolveUrl(url) {
        return new url_1.URL(url, this._base).href;
    }
}
exports.HTMLDocument = HTMLDocument;
